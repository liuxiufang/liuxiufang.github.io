
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>git | Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="[object Object]">
    

    
    <meta name="description" content="git的简介、安装、使用1. git的来源
Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？那么问题来了，很多有兴趣的编者，便开始自我研究，开发Samba的Andrew试图破解BitKe">
<meta property="og:type" content="article">
<meta property="og:title" content="git">
<meta property="og:url" content="http://yoursite.com/2016/03/06/git/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="git的简介、安装、使用1. git的来源
Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？那么问题来了，很多有兴趣的编者，便开始自我研究，开发Samba的Andrew试图破解BitKe">
<meta property="og:updated_time" content="2016-04-25T20:31:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="git">
<meta name="twitter:description" content="git的简介、安装、使用1. git的来源
Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？那么问题来了，很多有兴趣的编者，便开始自我研究，开发Samba的Andrew试图破解BitKe">

    
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
						<form class="search" action="http://zn.baidu.com/cse/searchbox/" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 4371549709810365400 ><input type="text" name="q" size="30" placeholder="Search"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/06/git/" title="git" itemprop="url">git</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="[object Object]" target="_blank" itemprop="author">[object Object]</a>
		
  <p class="article-time">
    <time datetime="2016-03-06T10:56:51.000Z" itemprop="datePublished"> Published 2016-03-06</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#git的简介、安装、使用"><span class="toc-text">git的简介、安装、使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-git的来源"><span class="toc-text">1. git的来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-git的安装"><span class="toc-text">2. git的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-git的使用"><span class="toc-text">3. git的使用</span></a></li></ol></li></ol></li></ol>
		
		</div>
		
		<h1 id="git的简介、安装、使用"><a href="#git的简介、安装、使用" class="headerlink" title="git的简介、安装、使用"></a>git的简介、安装、使用</h1><h3 id="1-git的来源"><a href="#1-git的来源" class="headerlink" title="1. git的来源"></a>1. git的来源</h3><blockquote>
<p>Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？那么问题来了，很多有兴趣的编者，便开始自我研究，开发Samba的Andrew试图破解BitKeeper的协议，从此git便诞生了。</p>
<p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<p>有人又会说为 什么不用svn、 cvs 这些版本控制呢!那么小编会告诉你，svn、 cvs都是集中式的版本控制系统，而git 则是分布式版本控制系统，那么问题又来了，两者又有什么区别呢？</p>
<p>首先，集中式版本控制是存放在中央服务器的，而开发者是从本地工作的，所以工作者是从中央服务器取得最新的版本，然后进行工作，工作完成后，在把文件推送给中央服务器， 由此可见，如果中央服务器出现问题，那么工作者就不能愉快的工作了，而且集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。<br>哪布式版本控制系统又如何工作呢？分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。也可以通过github 存储托管， 工作完成后可以推送给github，方便其他的工作者方便的使用和继承。</p>
<p>简单的介绍下，那么现在小编带你们开始安装和使用git！</p>
</blockquote>
<h3 id="2-git的安装"><a href="#2-git的安装" class="headerlink" title="2. git的安装"></a>2. git的安装</h3><p>首先，你可以试着输入git，看看系统有没有安装Git：<br>一般linux 会自带git 功能,那么接下来可以设置一下自己所属git的</p>
<p><code>$ git config --global user.name &quot;Your Name&quot;</code><br><code>$ git config --global user.email &quot;email@example.com&quot;</code>  </p>
<p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址 </p>
<p>那么好现在才刚刚开始使用git!  </p>
<h3 id="3-git的使用"><a href="#3-git的使用" class="headerlink" title="3. git的使用"></a>3. git的使用</h3><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br><code>mkdir learngit</code><br>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。<br><code>$ git init</code><br>初始化仓库<br><code>Initialized empty Git repository in /Users/michael/learngit/.git/</code><br>瞬间git仓库创建好了，那么会在目录下面生生一.git的目录可用ls -ah 查看<br>把文件添加到仓库 总共分两步:<br><code>$ git add file.txt</code><br><code>$ git commit -m &quot;describe&quot;</code><br>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<br>嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。<br>现在我们成功提交了一个文件到仓库中，那么可以查看一下状态，看看有木有修改过的文件<br><code>$ git status</code><br><code># On branch master</code><br><code># Changes not staged for commit:</code><br><code>#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</code><br><code>#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</code><br><code>#</code><br><code>#    modified:   readme.txt</code><br><code>#</code><br><code>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code><br>也可以通过<br><code>$ git diff</code><br>来对比两个文件的差异<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git diff readme.txt  </span><br><span class="line">diff --git a/readme.txt b/readme.txt  </span><br><span class="line">index 46d49bf..9247db6 100644  </span><br><span class="line">--- a/readme.txt  </span><br><span class="line">+++ b/readme.txt  </span><br><span class="line">@@ -1,2 +1,2 @@  </span><br><span class="line">-Git is a version control system.  </span><br><span class="line">+Git is a distributed version control system.  </span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure></p>
<p> git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。<br> 想查看git的日志可以<br> <code>$ git log</code><br> git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> $ git log --pretty=oneline  </span><br><span class="line">3628164fb26d48395383f8f31179f24e0882e1e0 append GPL  </span><br><span class="line">ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed  </span><br><span class="line">cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file  </span><br><span class="line">```  </span><br><span class="line">需要友情提示的是，你看到的一大串类似3628164...882e1e0的是commit id（版本号），和SVN不一样，Git的commitid不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。  </span><br><span class="line"></span><br><span class="line">每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：  </span><br><span class="line"></span><br><span class="line">如果提交了文件，存在错误想撤销回到上一个版本：</span><br></pre></td></tr></table></figure></p>
<p>$ git reset –hard HEAD^<br>HEAD is now at ea34578 add distributed<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。  </span><br><span class="line"></span><br><span class="line">例如:</span><br></pre></td></tr></table></figure></p>
<p>$ git log<br>commit ea34578d5496d7dd233c827ed32a8cd576c5ee85<br>Author: Michael Liao <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x61;&#x73;&#107;&#120;&#x75;&#x65;&#102;&#101;&#x6e;&#x67;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;">&#x61;&#x73;&#107;&#120;&#x75;&#x65;&#102;&#101;&#x6e;&#x67;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a><br>Date:   Tue Aug 20 14:53:12 2013 +0800  </p>
<pre><code>add distributed  
</code></pre><p>commit cb926e7ea50ad11b8f9e909c05226233bf755030<br>Author: Michael Liao <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#97;&#115;&#107;&#120;&#x75;&#x65;&#102;&#x65;&#110;&#103;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;">&#97;&#115;&#107;&#120;&#x75;&#x65;&#102;&#x65;&#110;&#103;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;</a><br>Date:   Mon Aug 19 17:51:55 2013 +0800  </p>
<pre><code>wrote a readme file  
</code></pre><p>$ git reset –hard 3628164<br>HEAD is now at 3628164 append GPL  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">那么文件已经成功的回退到指定的版本。  </span><br><span class="line">现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？  </span><br><span class="line"></span><br><span class="line">在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</span><br></pre></td></tr></table></figure>
<p>$ git reflog<br>ea34578 HEAD@{0}: reset: moving to HEAD^<br>3628164 HEAD@{1}: commit: append GPL<br>ea34578 HEAD@{2}: commit: add distributed<br>cb926e7 HEAD@{3}: commit (initial): wrote a readme file  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">说到这里，那么下面来认识一下git 工作区和暂存区  </span><br><span class="line"></span><br><span class="line">所谓的工作区，就是你现在本地的能看的目录比如刚刚创建的learngit就是你的工作区  </span><br><span class="line">版本库：就是你通过 $ git commit 把目录提交到的地方，  </span><br><span class="line">前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</span><br><span class="line"></span><br><span class="line">第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；  </span><br><span class="line"></span><br><span class="line">第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 </span><br><span class="line"></span><br><span class="line">可以查看暂存区和最近一次提交的不同:  </span><br><span class="line">` $ git diff --cached `  </span><br><span class="line">注意的是，只有在 暂存区的文件commit后才能提交到版本库当中。  </span><br><span class="line"></span><br><span class="line">git diff：是查看工作区与暂存区的差别的。   </span><br><span class="line">git diff --cached：是查看暂存区与commit的差别的。  </span><br><span class="line">git diff HEAD：是查看工作区和commit的差别的。（你一定没有忘记，HEAD代表的是最近的一次commit的信息）  </span><br><span class="line"></span><br><span class="line">学会了 提交、查看那么又有人会问到，如果我写错了，想撤销我刚才的操作该如何做呢！别急下面介绍一下如何撤销：  </span><br><span class="line">你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改：  </span><br><span class="line">`$ git checkout -- readme.txt`  </span><br><span class="line">命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：  </span><br><span class="line">一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；  </span><br><span class="line">一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。  </span><br><span class="line">总之，就是让这个文件回到最近一次git commit或git add时的状态。  </span><br><span class="line"></span><br><span class="line">Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：</span><br></pre></td></tr></table></figure>
<p>$ git reset HEAD readme.txt<br>Unstaged changes after reset:<br>M       readme.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。  </span><br><span class="line"></span><br><span class="line">创建完了，那么我想删除刚刚创建的文件该如何操作呢?    </span><br><span class="line">第一步：首先是从你本地删除，第二步其次是从版本库中删除掉</span><br></pre></td></tr></table></figure>
<p>$ git rm test.txt<br>rm ‘test.txt’<br>$ git commit -m “remove test.txt”<br>[master d17efd8] remove test.txt<br> 1 file changed, 1 deletion(-)<br> delete mode 100644 test.txt  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">现在，文件就从版本库中被删除了。  </span><br><span class="line"></span><br><span class="line">另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：  </span><br><span class="line"></span><br><span class="line">`$ git checkout -- test.txt`  </span><br><span class="line"></span><br><span class="line">git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。  </span><br><span class="line">命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。  </span><br><span class="line"></span><br><span class="line">到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。  </span><br><span class="line">其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。  </span><br><span class="line">实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</span><br><span class="line"></span><br><span class="line">完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。  </span><br><span class="line">在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：  </span><br><span class="line"></span><br><span class="line">####远程仓库连接  </span><br><span class="line"></span><br><span class="line">第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：  </span><br><span class="line"></span><br><span class="line">`$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;`  </span><br><span class="line"></span><br><span class="line">你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。  </span><br><span class="line"></span><br><span class="line">如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH   Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。  </span><br><span class="line"></span><br><span class="line">第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</span><br><span class="line"></span><br><span class="line">然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：   </span><br><span class="line">为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。  </span><br><span class="line"></span><br><span class="line">当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。  </span><br><span class="line"></span><br><span class="line">准备工作已经做好了，那么如何 让本地的文件同步到github上去呢？ 接下来小编告诉你。  </span><br><span class="line"></span><br><span class="line">首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：  </span><br><span class="line">在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：  </span><br><span class="line">现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：  </span><br><span class="line">` $ git remote add origin git@github.com:michaelliao/learngit.git `</span><br><span class="line">注意：把上面的michaelliao替换成你自己的GitHub账户名  </span><br><span class="line"></span><br><span class="line">添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。  </span><br><span class="line">下一步，就可以把本地库的所有内容推送到远程库上：</span><br></pre></td></tr></table></figure>
<p>$ git push -u origin master<br>Counting objects: 19, done.<br>Delta compression using up to 4 threads.<br>Compressing objects: 100% (19/19), done.<br>Writing objects: 100% (19/19), 13.73 KiB, done.<br>Total 23 (delta 6), reused 0 (delta 0)<br>To git@github.com:michaelliao/learngit.git  </p>
<ul>
<li>[new branch]      master -&gt; master<br>Branch master set up to track remote branch master from origin.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。  </span><br><span class="line"></span><br><span class="line">由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。  </span><br><span class="line"></span><br><span class="line">推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样  </span><br><span class="line"></span><br><span class="line">从现在起，只要本地作了提交，就可以通过命令：  </span><br><span class="line"></span><br><span class="line">` $ git push origin master `</span><br></pre></td></tr></table></figure>
<p>去除本地仓库与远程仓库的关联: $ git remote rm origin(远程仓库)<br>克隆了别人的远程仓库到自己本地工作区，但是想把这种关联到自己的远层仓库:$ git remote set-url origin git@your-new-url  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SSH警告  </span><br><span class="line"></span><br><span class="line">当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：  </span><br><span class="line"></span><br><span class="line">The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.  </span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.  </span><br><span class="line">Are you sure you want to continue connecting (yes/no)?  </span><br><span class="line"></span><br><span class="line">这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。  </span><br><span class="line"></span><br><span class="line">Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：  </span><br><span class="line"></span><br><span class="line">Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts.  </span><br><span class="line"></span><br><span class="line">这个警告只会出现一次，后面的操作就不会有任何警告了。  </span><br><span class="line"></span><br><span class="line">如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。  </span><br><span class="line"></span><br><span class="line">如何让github的文件克隆到本地的工作区域中：</span><br></pre></td></tr></table></figure>
<p>$ git clone git@github.com:michaelliao/gitskills.git<br>Cloning into ‘gitskills’…<br>remote: Counting objects: 3, done.<br>remote: Total 3 (delta 0), reused 0 (delta 0)<br>Receiving objects: 100% (3/3), done.  </p>
<p>$ cd gitskills<br>$ ls<br>README.md  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。  </span><br><span class="line">那么开始创建一个分支  </span><br><span class="line"></span><br><span class="line">首先，我们创建dev分支，然后切换到dev分支：</span><br></pre></td></tr></table></figure>
<p>$ git checkout -b dev<br>Switched to a new branch ‘dev’  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</span><br></pre></td></tr></table></figure>
<p>$ git branch dev<br>$ git checkout dev<br>Switched to branch ‘dev’  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后，用git branch命令查看当前分支：</span><br></pre></td></tr></table></figure>
<p>$ git branch  </p>
<ul>
<li>dev<br>master  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch命令会列出所有分支，当前分支前面会标一个*号。  </span><br><span class="line"></span><br><span class="line">然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：  </span><br><span class="line"></span><br><span class="line">然后提交：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$ git add readme.txt<br>$ git commit -m “branch test”<br>[dev fec145a] branch test<br> 1 file changed, 1 insertion(+)  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在，dev分支的工作完成，我们就可以切换回master分支：</span><br></pre></td></tr></table></figure>
<p>$ git checkout master<br>Switched to branch ‘master’  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：  </span><br><span class="line"></span><br><span class="line">现在，我们把dev分支的工作成果合并到master分支上：</span><br></pre></td></tr></table></figure>
<p>$ git merge dev<br>Updating d17efd8..fec145a<br>Fast-forward<br> readme.txt |    1 +<br> 1 file changed, 1 insertion(+)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。  </span><br><span class="line"></span><br><span class="line">注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。  </span><br><span class="line"></span><br><span class="line">当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。  </span><br><span class="line"></span><br><span class="line">合并完成后，就可以放心地删除dev分支了：</span><br></pre></td></tr></table></figure></p>
<p>$ git branch -d dev<br>Deleted branch dev (was fec145a).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">删除后，查看branch，就只剩下master分支了：  </span><br><span class="line"></span><br><span class="line">$ git branch  </span><br><span class="line">* master  </span><br><span class="line"></span><br><span class="line">因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。  </span><br><span class="line"></span><br><span class="line"> Git鼓励大量使用分支：  </span><br><span class="line"></span><br><span class="line">查看分支：git branch  </span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;  </span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;  </span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;  </span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;  </span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;  </span><br><span class="line"></span><br><span class="line">有分支就会有冲突  </span><br><span class="line">如果您把分支上的文件修改后，提交到版本库中，切换到主干上，然后修改文件后 也提交，然后合并分支和master上面的 内容，就会发生 冲突我们可以直接查看readme.txt的内容：</span><br></pre></td></tr></table></figure></p>
<pre><code>Git is a distributed version control system.  
Git is free software distributed under the GPL.  
Git has a mutable index called stage.  
Git tracks changes of files.    
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple. 再提交：</span><br></pre></td></tr></table></figure>
<pre><code>$ git add readme.txt   
$ git commit -m &quot;conflict fixed&quot;  
[master 59bc1cb] conflict fixed   
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">冲突解决了，可以安心 编写程序了  </span><br><span class="line"></span><br><span class="line">还可以用带参数的git log也可以看到分支的合并情况：</span><br></pre></td></tr></table></figure>
<p>$ git log –graph –pretty=oneline –abbrev-commit  </p>
<ul>
<li>59bc1cb conflict fixed<br>|\<br>| * 75a857c AND simple  </li>
<li>| 400b400 &amp; simple<br>|/  </li>
<li>fec145a branch test<br>…  </li>
</ul>
<p>最后，删除feature1分支：  </p>
<p>$ git branch -d feature1<br>Deleted branch feature1 (was 75a857c).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。  </span><br><span class="line">如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。  </span><br><span class="line">准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：</span><br></pre></td></tr></table></figure></p>
<p>$ git merge –no-ff -m “merge with no-ff” dev<br>Merge made by the ‘recursive’ strategy.<br> readme.txt |    1 +<br> 1 file changed, 1 insertion(+)<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。  </span><br><span class="line"></span><br><span class="line">合并后，我们用git log看看分支历史：</span><br></pre></td></tr></table></figure></p>
<p>$ git log –graph –pretty=oneline –abbrev-commit  </p>
<ul>
<li>7825a50 merge with no-ff<br>|\<br>| * 6224937 add merge<br>|/  </li>
<li>59bc1cb conflict fixed<br>…  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那么分支也创建完成，小编想看下我管理的所有仓库：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$ git remote -v<br>origin  git@github.com:michaelliao/learngit.git (fetch)<br>origin  git@github.com:michaelliao/learngit.git (push)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。  </span><br><span class="line"></span><br><span class="line">查看了有几个仓库后，小编看了看分支，时间久了后，却忘记了当时创建分支的初衷，后便又想起来，给分支加上标签：  </span><br><span class="line">敲命令git tag &lt;name&gt;就可以打一个新标签：  </span><br><span class="line"></span><br><span class="line">`$ git tag v1.0`  </span><br><span class="line"></span><br><span class="line">可以用命令git tag查看所有标签：  </span><br><span class="line"></span><br><span class="line">`$ git tag`  </span><br><span class="line">`v1.0`  </span><br><span class="line"></span><br><span class="line">默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？  </span><br><span class="line"></span><br><span class="line">方法是找到历史提交的commit id，然后打上就可以了：</span><br></pre></td></tr></table></figure>
<pre><code>$ git log --pretty=oneline --abbrev-commit  
6a5819e merged bug fix 101  
cc17032 fix bug 101  
7825a50 merge with no-ff  
6224937 add merge  
59bc1cb conflict fixed  
400b400 &amp; simple  
75a857c AND simple  
fec145a branch test  
d17efd8 remove test.txt  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：</span><br><span class="line"></span><br><span class="line">`$ git tag v0.9 6224937`  </span><br><span class="line"></span><br><span class="line">注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息：</span><br></pre></td></tr></table></figure>
<pre><code>$ git show v0.9  
commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4  
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;  
Date:   Thu Aug 22 11:22:08 2013 +0800  

add merge  
</code></pre><p>…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以看到，v0.9确实打在add merge这次提交上。  </span><br><span class="line"></span><br><span class="line">还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：  </span><br><span class="line"></span><br><span class="line">`$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164`  </span><br><span class="line"></span><br><span class="line">如果标签打错了，也可以删除：</span><br></pre></td></tr></table></figure></p>
<pre><code>$ git tag -d v0.1  
Deleted tag &apos;v0.1&apos; (was e078af9)  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。  </span><br><span class="line"></span><br><span class="line">如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;：</span><br></pre></td></tr></table></figure>
<pre><code>$ git push origin v1.0  
Total 0 (delta 0), reused 0 (delta 0)  
To git@github.com:michaelliao/learngit.git  
 * [new tag]         v1.0 -&gt; v1.0  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">或者，一次性推送全部尚未推送到远程的本地标签：</span><br></pre></td></tr></table></figure>
<pre><code>$ git push origin --tags  
Counting objects: 1, done.  
Writing objects: 100% (1/1), 554 bytes, done.  
Total 1 (delta 0), reused 0 (delta 0)  
To git@github.com:michaelliao/learngit.git  
 * [new tag]         v0.2 -&gt; v0.2  
 * [new tag]         v0.9 -&gt; v0.9  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</span><br></pre></td></tr></table></figure>
<p>$ git tag -d v0.9<br>Deleted tag ‘v0.9’ (was 6224937)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后，从远程删除。删除命令也是push，但是格式如下：</span><br></pre></td></tr></table></figure></p>
<p>$ git push origin :refs/tags/v0.9<br>To git@github.com:michaelliao/learngit.git  </p>
<ul>
<li>[deleted]         v0.9  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要看看是否真的从远程库删除了标签，可以登陆GitHub查看。    </span><br><span class="line">  </span><br><span class="line">有没有经常敲错命令？比如git status？status这个单词真心不好记。  </span><br><span class="line"></span><br><span class="line">如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。  </span><br><span class="line"></span><br><span class="line">我们只需要敲一行命令，告诉Git，以后st就表示status：  </span><br><span class="line"></span><br><span class="line">`$ git config --global alias.st status`  </span><br><span class="line"></span><br><span class="line">当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$ git config –global alias.co checkout<br>$ git config –global alias.ci commit<br>$ git config –global alias.br branch<br>```</p>
<p>以后提交就可以简写成：  </p>
<p><code>$ git ci -m &quot;bala bala bala...&quot;</code>  </p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/git安装/">git安装</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/03/06/git/" data-title="git | Hexo" data-tsina="5111832329" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/03/06/hexo/" title="hexo">
  <strong>上一篇：</strong><br/>
  <span>
  hexo</span>
</a>
</div>


</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/03/06/git/" data-title="git" data-url="http://yoursite.com/2016/03/06/git/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#git的简介、安装、使用"><span class="toc-text">git的简介、安装、使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-git的来源"><span class="toc-text">1. git的来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-git的安装"><span class="toc-text">2. git的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-git的使用"><span class="toc-text">3. git的使用</span></a></li></ol></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github Card</p>
<div class="github-card" data-github="liuxiufang" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/git安装/" title="git安装">git安装<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git-rebase/" title="git rebase">git rebase<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/angular/" title="angular">angular<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/laravel-time/" title="laravel-time">laravel-time<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/hexo使用/" title="hexo使用">hexo使用<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=5111832329&verifier=3a5cfaa2&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m liuxiufang Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5111832329" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/liuxiufang" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:xiufang1991@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="[object Object]">[object Object]</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"liuxiufang"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'liuxiufang';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
