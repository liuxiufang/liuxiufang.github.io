<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/hello-world/" class="article-date">
  <time datetime="2016-04-26T11:41:04.139Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/26/hello-world/" data-id="cinhdu2lr0000e4vd7xbh9302" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/04/26/hello-world/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-angular" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/angular/" class="article-date">
  <time datetime="2016-04-26T08:35:42.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/angular/">理解ANGULAR中的$APPLY()以及 $DIGEST()</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="一、-Applay-和-digest-工作原理"><a href="#一、-Applay-和-digest-工作原理" class="headerlink" title="一、$Applay()和$digest()工作原理"></a>一、$Applay()和$digest()工作原理</h4><p>   ANGULARJS提供了超级好的特性双向数据绑定，即MVVM，也就意味着，当VIEW中有任何数据发生变化，那么这个变化也会自动的反馈到SCOPE的数据模型上去，随之会自动更新，  </p>
<p>  那么相反当SCOPE模型发生变化时，VIEW中的数据也会随之更新到最新的值，当你在ANGULARJS中写下表达式如：时，随之ANUGLARJS在幕后会为你在SCOPE模型上设置一个新的WATCHER。  </p>
<p>  它用来在数据发生变化的时候更新VIEW,这里的WATCHER和你在ANGULARJS中设置的WATCHER是一样的： </p>
<blockquote>
<p>$SCOPE.$WATCH(‘MODEL’,FUNCTION(NEWVALUE,OLDVALUE){  </p>
</blockquote>
<pre><code>//UPDATE THE DOM WITH NEW VALUE  
</code></pre><p>   })</p>
<blockquote>
</blockquote>
<p>   传入到$WATCH()中的第二个参数是一个回调函数，该函数在MODEL的值发生变化的时候会被调用，<br>   当MODEL发生变化的时候，做这个回调函数会被调用来更新VIEW，那么问题来了，ANGULARJS是如何知道什么时候要去调用这个回调函数呢？<br>   它会周期性的运行一个函数来检查SCOPE模型中的数据是否发生了变化吗？好吧，这就是$DIGEST循环的用武之地。</p>
<p>   在$DIGEST循环中，WATCHERS会被触发，当一个WATCHER被触发是，ANGULARJS会检测SCOPE模型，那么它发生了变化，WATCHER的回调函数就会被调用。又有人会疑惑了，$DIGEST循环是在什么时候开始的呢，并且以什么方式开始的呢？  </p>
<p>   在调用了$SCOPE.$DIGEST()后，$DIGEST循环就开始了，假设你在一个NG-CLICK指令对应的HANDLER函数中更改了SCOPE中的一条数据，此时ANGULARJS会自动通过调用$DIGEST来触发一轮$DIGEST循环，当循环开始后，它会自动触发每一个的WATCHER。  </p>
<p>   这些WATCHERS会检查SCOPE中的当前MODEL值是否和上次计算得到的MODEL值不同。如果不同，那么对应的回调会被执行，调用该函数的结果，就是VIEW中的表达式内容，例如 除了NG-CLICK指令，还有一些其他的BUILT-IN指令以及服务来让你更改MODELS（比如NG-MODEL ,$TIMEOUT等）和自动触发一次\$DIGEST循环。</p>
<p>   那么对此ANGULARJS并不能直接调用$DIGEST()，而是调用$SCOPE.$APPLY(),后者是会调用$ROOTSCOPE.$DIGEST()。因此，一轮$DIGEST循环在$ROOTSCOPE开始，随后会访问到所有的CHILDREN SCOPE中的WATCHERS。  </p>
<p>   现在，假设你讲NG-CLICK指令关联到一个BUTTON上，并传入一个FUNCTION名到NG-CLICK上。当BUTTON被点击是，ANGULARJS会将FUNCTION包装到一个WRAPPING FUNCITON 中，然后传入到$SCOPE.$APPLY()。因此你的FUNCTION会正常执行，修改MODELS此时一轮$DIGEST循环也会被触发，用来确保VIEW也会被更新</p>
<p>   <code>注意：$SCOPE.$APPLY()会自动调用$ROOTSCOPE.$DIGEST()。$APPLY()方法有两种形式，第一种会接受一个FUNCTION作为参数，执行该FUNCTION并且触发一轮$DIGEST循环。</code>  </p>
<h4 id="二、-手动调用-APPLY-方法"><a href="#二、-手动调用-APPLY-方法" class="headerlink" title="二、 手动调用$APPLY()方法"></a>二、 手动调用$APPLY()方法</h4><p>  如果ANGULARJS总是将我们的代码WRAP到一个FUNCTION中并传入$APPLY()，以此来开始一轮$DIGEST循环，那么什么时候才需要我们手动地调用$APPLY()方法呢？实际上，ANGULARJS对此有着非常明确的要求，就是它只负责对发生于ANGULARJS上下文环境中的变更会做出自动地响应(即，在$APPLY()方法中发生的对于MODELS的更改)。</p>
<p>  ANGULARJS的BUILT-IN指令就是这样做的，所以任何的MODEL变更都会被反映到VIEW中。但是，如果你在ANGULARJS上下文之外的任何地方修改了MODEL，那么你就需要通过手动调用$APPLY()来通知ANGULARJS。这就像告诉ANGULARJS，你修改了一些MODELS，希望ANGULARJS帮你触发WATCHERS来做出正确的响应。  </p>
<p>  比如，如果你使用了JavaScript中的setTimeout()来更新一个scope model，那么AngularJS就没有办法知道你更改了什么。这种情况下，调用$apply()就是你的责任了，通过调用它来触发一轮$digest循环。类似地，如果你有一个指令用来设置一个DOM事件listener并且在该listener中修改了一些models，那么你也需要通过手动调用$apply()来确保变更会被正确的反映到view中。  </p>
<p>   <code>HTML:</code>  </p>
<blockquote>
<p>[html] view plain copy print?</p>
</blockquote>
<pre><code>&lt;body ng-app=&quot;myApp&quot;&gt;  
  &lt;div ng-controller=&quot;MessageController&quot;&gt;  
    Delayed Message: {{message}}  
  &lt;/div&gt;    
&lt;/body&gt;  
</code></pre><p>  &gt;</p>
<p>  <code>JavaScript:</code>  </p>
<blockquote>
<p>[javascript] view plain copy print?</p>
</blockquote>
<pre><code>/* What happens without an $apply() */  

    angular.module(&apos;myApp&apos;,[]).controller(&apos;MessageController&apos;, function($scope) {  

      $scope.getMessage = function() {  
        setTimeout(function() {  
          $scope.message = &apos;Fetched after 3 seconds&apos;;  
          console.log(&apos;message:&apos;+$scope.message);  
        }, 2000);  
      }  

      $scope.getMessage();  

    });  
</code></pre><p>通过运行这个例子，你会看到过了两秒钟之后，控制台确实会显示出已经更新的model，然而，view并没有更新。原因也许你已经知道了，就是我们忘了调用$apply()方法。因此，我们需要修改getMessage()，如下所示：</p>
<p>[javascript] view plain copy print?</p>
<pre><code>/* What happens with $apply */   
angular.module(&apos;myApp&apos;,[]).controller(&apos;MessageController&apos;, function($scope) {  

      $scope.getMessage = function() {  
        setTimeout(function() {  
          $scope.$apply(function() {  
            //wrapped this within $apply  
            $scope.message = &apos;Fetched after 3 seconds&apos;;   
            console.log(&apos;message:&apos; + $scope.message);  
          });  
        }, 2000);  
      }  

      $scope.getMessage();  

    });  
</code></pre><p>如果你运行了上面的例子，你会看到view在两秒钟之后也会更新。唯一的变化是我们的代码现在被wrapped到了$scope.$apply()中，它会自动触发$rootScope.$digest()，从而让watchers被触发用以更新view。  </p>
<p><code>顺便提一下，你应该使用$timeout service来代替setTimeout()，因为前者会帮你调用$apply()，让你不需要手动地调用它。</code>  </p>
<p>而且，注意在以上的代码中你也可以在修改了model之后手动调用没有参数的$apply()，就像下面这样：</p>
<p>[javascript] view plain copy print?</p>
<pre><code>$scope.getMessage = function() {  
  setTimeout(function() {  
    $scope.message = &apos;Fetched after two seconds&apos;;  
    console.log(&apos;message:&apos; + $scope.message);  
    $scope.$apply(); //this triggers a $digest  
  }, 2000);  
}; 
</code></pre><p> 以上的代码使用了$apply()的第二种形式，也就是没有参数的形式，需要记住的是你总是应该使用接受一个function作为参数的$apply()方法，这是因为当你传入一个function到$apply中的时候，这个function会被包装到一个try .. catch块中，所以一旦有异常发生，该异常会被$exceptionHandler service 处理。  </p>
<h4 id="三、-digest循环会运行的次数"><a href="#三、-digest循环会运行的次数" class="headerlink" title="三、 $digest循环会运行的次数"></a>三、 $digest循环会运行的次数</h4><p>当一个$digest循环运行是，watchers会被执行来检查scope中的models是否发生变化，如果发生变化，那么相应的listener函数就会被执行，这涉及到一个重要的问题，如果listener函数本身会修改一个scope model呢？ AngularJs会怎么处理这种情况呢？  </p>
<p>$digest循环不会只运行一次的，在当期的一次循环结束后，它会在执行一次循环用来检测是否有models发生了变化，这就是脏检查，它用来处理listener函数被执行时可能引起的model变化。<br>因此，$digest循环会持续运行直到model不在发生变化，或者$digest循环的次数到了10次，因此，尽可能的不要在listener函数中修改model。<br>   <code>注意：$digest循环至少也会运行两次，即使在listener函数中并没有改变任何model。正如上面讨论的那样，它会多运行一次来确保model没有变化</code> 。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/26/angular/" data-id="cinhdu2m00002e4vd6mz1ms3h" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/04/26/angular/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/angular/">angular</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/06/hexo/" class="article-date">
  <time datetime="2016-03-06T11:57:41.000Z" itemprop="datePublished">2016-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/06/hexo/">hexo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="hexo的简介"><a href="#hexo的简介" class="headerlink" title="hexo的简介"></a>hexo的简介</h1><blockquote>
<p>一直纠结于哪里写博客，曾用过新浪博客，百度空间，JavaEye，LOFTER，OSChina，cnblogs，CSDN，自搭WordPress，都不满意。再后来也弄过Jekyll和Octopress，觉累不爱。</p>
<p>直到多看了一眼hexo，这个逼格极高的程序猿写作方式，我喜欢。就连hexo的发音都像是黑客哦！如果你跟我一样纠结哪里写博，那就来到GitHub吧，让我们一起hexo！H人希绝对不会让你失望，相信很快hexo就会流行起来。</p>
<p>hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ Hexo颯爽登場。  </p>
</blockquote>
<p>只需要几个简单命令，你就可以完成一切。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n #写文章  </span><br><span class="line">hexo g #生成  </span><br><span class="line">hexo d #部署 # 可与hexo g合并为 hexo d -g</span><br></pre></td></tr></table></figure>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ol>
<li><p>安装Node<br>到Node.js官网下载相应平台的最新版本，一路安装即可。我用的是node-v0.10.22-x86.msi</p>
</li>
<li><p>安装Git<br>Git的客户端很多，我用的是msysgit，喜欢用绿色版本Portable application for official Git for Windows 1.8.4，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\bin之类的，不多说。</p>
</li>
<li><p>安装Sublime（可选）<br>Sublime Text 2在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的Sublime Text 3。我用绿色版本Portable Sublime Text 2.0.2.zip。  </p>
</li>
<li><p>GitHub  </p>
</li>
</ol>
<p>GitHub账号和GitHub Pages 一般都应该有吧，已有的请自动无视这一部分。 </p>
<p>首先注册一个『GitHub』帐号，已有的默认默认请忽略<br>建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』<br>添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』(生成key的方法  在要安装的git的目录中$ git init)</p>
<p><img src="img/my-github-pages.jpg" alt="github">  </p>
<p>前两步忽略，只说第三步，添加SSH-Key。<br>首先设置你的用户名密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;bu.ru@qq.com&quot;  </span><br><span class="line">git config --global user.name &quot;bruce-sha&quot;</span><br></pre></td></tr></table></figure></p>
<p>生成密钥:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;bu.ru@qq.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">H:\hexo\blog&gt;ssh-keygen -t rsa -C &quot;bu.ru@qq.com&quot;  </span><br><span class="line">Generating public/private rsa key pair.  </span><br><span class="line">Enter file in which to save the key (//.ssh/id_rsa): H:\git\myssh\ssh  </span><br><span class="line">Enter passphrase (empty for no passphrase):  </span><br><span class="line">Enter same passphrase again:  </span><br><span class="line">Your identification has been saved in H:\git\myssh\ssh.  </span><br><span class="line">Your public key has been sa  ved in H:\git\myssh\ssh.pub.  </span><br><span class="line">The key fingerprint is:  </span><br><span class="line">b0:0c:2e:67:33:ab:c1:50:10:40:0a:ba:c1:80:59:22 bu.ru@qq.com</span><br></pre></td></tr></table></figure></p>
<p>上述命令若执行成功，会在H:\git\myssh目录下生成两个文件id_rsa和id_rsa.pub，最后两步:    </p>
<ol>
<li>用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到Add SSH Key  </li>
<li>将id_rsa和id_rsa.pub拷贝至你Git安装目录下的.ssh目录，如H:\PortableGit-1.8.4.ssh  </li>
</ol>
<p><img src="img/add-ssh-keys.jpg" alt="连接key">  </p>
<p>最后可以验证一下：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	ssh -T git@github.com  </span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"># 安装及使用   </span><br><span class="line"></span><br><span class="line">Node和Git都安装好后，可执行如下命令安装hexo  </span><br><span class="line">```  </span><br><span class="line">	npm install -g hexo</span><br></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>然后，执行init命令初始化hexo到你指定的目录：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure>
<p>也可以cd到目标目录，执行hexo init。  </p>
<h4 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h4><p>cd 到你的init目录，执行如下命令，生成静态页面至hexo\public\目录。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令必须在init目录下执行，否则不成功，但是也不报错。<br>当你修改文章Tag或内容，不能正确重新生成内容，可以删除hexo\db.json后重试，还不行就到public目录删除对应的文件，重新生成。  </p>
</blockquote>
<h4 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h4><p>执行如下命令，启动本地服务，进行文章预览调试。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>浏览器输入<a href="http://localhost:4000就可以看到效果" target="_blank" rel="external">http://localhost:4000就可以看到效果</a>  </p>
<h4 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h4><p>执行new命令，生成指定名称的文章至hexo\source_posts\postName.md。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	hexo new [layout] &quot;postName&quot; #新建文章  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&gt; 其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\scaffolds\post.md</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">	title: &#123; &#123; title &#125; &#125;  </span><br><span class="line">	date: &#123; &#123; date &#125; &#125;  </span><br><span class="line">	tags:  </span><br><span class="line">	---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，所有文件：后面都必须有个空格，不然会报错。 </p>
</blockquote>
<p>看一下刚才生成的文件hexo\source_posts\postName.md，内容如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中  </span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改    </span><br><span class="line">categories: #文章分类目录，可以为空，注意:后面有个空格  </span><br><span class="line">tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格  </span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这里开始使用markdown格式输入你的正文。  </p>
<h5 id="fancybox"><a href="#fancybox" class="headerlink" title="fancybox"></a>fancybox</h5><p>可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。<br>很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">layout: photo  </span><br><span class="line">title: 我的阅历  </span><br><span class="line">date: 2085-01-16 07:33:44  </span><br><span class="line">tags: [hexo]  </span><br><span class="line">photos:  </span><br><span class="line">- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg   </span><br><span class="line">- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg   </span><br><span class="line">经过测试，文件头上的layout: photo可以省略。</span><br></pre></td></tr></table></figure>
<p>不想每次都手动添加怎么办？同样的，打开您的hexo\scaffolds\photo.md  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout: &#123; &#123; layout &#125; &#125;</span><br><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line">tags: </span><br><span class="line">photos: </span><br><span class="line">- </span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>然后每次可以执行带layout的new命令生成照片文章：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new photo &quot;photoPostName&quot; #新建照片文章</span><br></pre></td></tr></table></figure>
<h5 id="description"><a href="#description" class="headerlink" title="description"></a>description</h5><p>markdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">	title: hexo你的博客  </span><br><span class="line">	date: 2013-11-22 17:11:54  </span><br><span class="line">	categories: default  </span><br><span class="line">	tags: [hexo]    </span><br><span class="line">	description: 你对本页的描述  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&gt; hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">文章摘要  </span><br><span class="line">在需要显示摘要的地方添加如下代码即可：  </span><br><span class="line"></span><br><span class="line">以上是摘要  </span><br><span class="line">&lt;!--more--&gt;  </span><br><span class="line">以下是余下全文   </span><br><span class="line"></span><br><span class="line">more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。  </span><br><span class="line"></span><br><span class="line">&gt; hexo中所有文件的编码格式均是UTF-8。 </span><br><span class="line"></span><br><span class="line">#  主题安装   </span><br><span class="line"></span><br><span class="line">1. 安装主题的方法就是一句git命令： </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">	git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist  </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt; 目录是否是modernist无所谓，只要与_config.yml文件一致即可。  </span><br><span class="line"></span><br><span class="line">安装完成后，打开hexo\_config.yml，修改主题为modernist  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">theme: modernist</span><br></pre></td></tr></table></figure>
<ol>
<li>打开hexo\themes\modernist目录，编辑主题配置文件_config.yml：  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">menu: #配置页头显示哪些菜单</span><br><span class="line">#  Home: /</span><br><span class="line">  Archives: /archives</span><br><span class="line">  Reading: /reading</span><br><span class="line">  About: /about</span><br><span class="line">#  Guestbook: /about</span><br><span class="line"></span><br><span class="line">excerpt_link: Read More #摘要链接文字</span><br><span class="line">archive_yearly: false #按年存档</span><br><span class="line"></span><br><span class="line">widgets: #配置页脚显示哪些小挂件</span><br><span class="line">  - category</span><br><span class="line">#  - tag</span><br><span class="line">  - tagcloud</span><br><span class="line">  - recent_posts</span><br><span class="line">#  - blogroll</span><br><span class="line"></span><br><span class="line">blogrolls: #友情链接</span><br><span class="line">  - bruce sha&apos;s duapp wordpress: http://ibruce.duapp.com</span><br><span class="line">  - bruce sha&apos;s javaeye: http://buru.iteye.com</span><br><span class="line">  - bruce sha&apos;s oschina blog: http://my.oschina.net/buru</span><br><span class="line">  - bruce sha&apos;s baidu space: http://hi.baidu.com/iburu</span><br><span class="line"></span><br><span class="line">fancybox: true #是否开启fancybox效果</span><br><span class="line"></span><br><span class="line">duoshuo_shortname: buru #多说账号</span><br><span class="line"></span><br><span class="line">google_analytics:</span><br><span class="line">rss:</span><br></pre></td></tr></table></figure>
<ol>
<li>更新主题   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes/modernist  </span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="评论框"><a href="#评论框" class="headerlink" title="评论框"></a>评论框</h1><p>静态博客要使用第三方评论系统，hexo默认集成的是Disqus，因为你懂的，所以国内的话还是建议用多说。<br>直接用你的微博/豆瓣/人人/百度/开心网帐号登录多说，做一下基本设置。如果使用modernist主题，在modernist_config.yml中配置duoshuo_shortname为多说的基本设置-&gt;域名中的shortname即可。你也可以在多说后台自定义一下多说评论框的格式，比如评论框的位置，对于css设置，可以参考这里，我是在HeroicYang的基础上修改的。  </p>
<p>如果你是有的其他第三方评论系统，将通用代码粘贴到hexo\themes\modernist\layout_partial\comment.ejs里面，如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (config.disqus_shortname &amp;&amp; page.comments)&#123; %&gt;  </span><br><span class="line">&lt;section id=&quot;comment&quot;&gt;  </span><br><span class="line">  #你的通用代码  </span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<h1 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h1><p>执行new page命令    </p>
<pre><code>hexo new page &quot;about&quot;
</code></pre><p>在hexo\source\下会生成about目录，里面有个index.md，直接编辑就可以了，然后在主题的_config.yml中将其配置显示出来。<br>上述步骤，也可以手工生成，在hexo\source\下手工新建about和index.md也是完全等价的。<br>因为markdown对table的支持不好，我是在about中直接建立index.html，里面书写页面内容，hexo会帮你加上头和尾。  </p>
<h1 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h1><p>GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。<br>其实，404页面可以做更多有意义的事，来做个404公益项目吧。现在，看下我的404页面一个ibruce.info上不存在的页面，做点有意义的事情，也对得起这个域名。<br>目前有如下几个公益404接入地址，我选择了腾讯的。404页面，每个人可以做的更多。<br>腾讯公益404<br>404公益_益云(公益互联网)社会创新中心<br>失蹤兒童少年資料管理中心404  </p>
<h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><p>考虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。  </p>
<p>免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，不够的话点这个活动页面，也可通过邀请好友获得奖励，我也求一下七牛邀请。有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里关于key-value存储系统。  </p>
<p>七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇Linux中国采用七牛云存储支撑图片访问。  </p>
<p>如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。  </p>
<blockquote>
<p>如果你对七牛web版的文件管理界面不满意，可以用官方的七牛云存储工具。  </p>
</blockquote>
<p>您还可以使用如下图床服务 FarBox，Dropbox，又拍云。  </p>
<h1 id="申请域名（可选）"><a href="#申请域名（可选）" class="headerlink" title="申请域名（可选）"></a>申请域名（可选）</h1><p>GitHubPages默认为每个用户分配了一个二级域名『your_user_name.github.com』或『your_user_name.github.io』。<br>如果你对上述域名不满意，可以到狗爹上申请一个自己的域名，然后绑定到GitHub Pages。绑定方法很简单，在repo根目录下建立一个CNAME文件，里面写上域名即可。  </p>
<ol>
<li>GoDaddy<br>买域名首选狗爹，国内的服务商大家都懂的。<br>目前.info域名只要￥18.99，但据说续费比较贵，我是先玩下，一年后再换，至于搜索引擎重新索引之类的，无所谓。.me和.com域名稍微贵点，大约￥60-100，网上有很多优惠码可用，可惜有的优惠码有限制。比如有个.com域名优惠码只要$1.99，但只能用国外信用卡购买。更多优惠码可以自行谷歌或到独特优惠码找。不着急的同学可以将中意的域名加入购物车先不付款，过几天，狗爹就会发优惠信息给你。狗爹不定期也会有活动，可以多关注。<br>付款后，需要稍微等一会你才会拿到域名，特别是支付宝付款的，要等大约半小时左右。此外域名要一年年的买，这样比较划算。  </li>
</ol>
<blockquote>
<p>建议大家申请.com或.me域名。据说.info因垃圾网站太多，被搜索引擎惩罚，而且续费较贵。  </p>
</blockquote>
<ol>
<li>DNSPod<br>GoDaddy的NameServers有时会被墙，因此墙裂推荐国内的DNSPod解析域名，免费服务真心不错。支持微信/邮件提醒，监控与报警，访问统计，健康诊断，搜索引擎推送，速度哇哇的，对于我来说足够。<br>两步设置就可以搞定，怎么操作参考Godaddy注册商域名修改DNS地址。  </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/06/hexo/" data-id="cinhdu2me0006e4vdg0rv9u2w" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/03/06/hexo/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo使用/">hexo使用</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-git" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/06/git/" class="article-date">
  <time datetime="2016-03-06T10:56:51.000Z" itemprop="datePublished">2016-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/06/git/">git</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="git的简介、安装、使用"><a href="#git的简介、安装、使用" class="headerlink" title="git的简介、安装、使用"></a>git的简介、安装、使用</h1><h3 id="1-git的来源"><a href="#1-git的来源" class="headerlink" title="1. git的来源"></a>1. git的来源</h3><blockquote>
<p>Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？那么问题来了，很多有兴趣的编者，便开始自我研究，开发Samba的Andrew试图破解BitKeeper的协议，从此git便诞生了。</p>
<p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<p>有人又会说为 什么不用svn、 cvs 这些版本控制呢!那么小编会告诉你，svn、 cvs都是集中式的版本控制系统，而git 则是分布式版本控制系统，那么问题又来了，两者又有什么区别呢？</p>
<p>首先，集中式版本控制是存放在中央服务器的，而开发者是从本地工作的，所以工作者是从中央服务器取得最新的版本，然后进行工作，工作完成后，在把文件推送给中央服务器， 由此可见，如果中央服务器出现问题，那么工作者就不能愉快的工作了，而且集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。<br>哪布式版本控制系统又如何工作呢？分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。也可以通过github 存储托管， 工作完成后可以推送给github，方便其他的工作者方便的使用和继承。</p>
<p>简单的介绍下，那么现在小编带你们开始安装和使用git！</p>
</blockquote>
<h3 id="2-git的安装"><a href="#2-git的安装" class="headerlink" title="2. git的安装"></a>2. git的安装</h3><p>首先，你可以试着输入git，看看系统有没有安装Git：<br>一般linux 会自带git 功能,那么接下来可以设置一下自己所属git的</p>
<p><code>$ git config --global user.name &quot;Your Name&quot;</code><br><code>$ git config --global user.email &quot;email@example.com&quot;</code>  </p>
<p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址 </p>
<p>那么好现在才刚刚开始使用git!  </p>
<h3 id="3-git的使用"><a href="#3-git的使用" class="headerlink" title="3. git的使用"></a>3. git的使用</h3><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br><code>mkdir learngit</code><br>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。<br><code>$ git init</code><br>初始化仓库<br><code>Initialized empty Git repository in /Users/michael/learngit/.git/</code><br>瞬间git仓库创建好了，那么会在目录下面生生一.git的目录可用ls -ah 查看<br>把文件添加到仓库 总共分两步:<br><code>$ git add file.txt</code><br><code>$ git commit -m &quot;describe&quot;</code><br>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<br>嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。<br>现在我们成功提交了一个文件到仓库中，那么可以查看一下状态，看看有木有修改过的文件<br><code>$ git status</code><br><code># On branch master</code><br><code># Changes not staged for commit:</code><br><code>#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</code><br><code>#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</code><br><code>#</code><br><code>#    modified:   readme.txt</code><br><code>#</code><br><code>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code><br>也可以通过<br><code>$ git diff</code><br>来对比两个文件的差异<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git diff readme.txt  </span><br><span class="line">diff --git a/readme.txt b/readme.txt  </span><br><span class="line">index 46d49bf..9247db6 100644  </span><br><span class="line">--- a/readme.txt  </span><br><span class="line">+++ b/readme.txt  </span><br><span class="line">@@ -1,2 +1,2 @@  </span><br><span class="line">-Git is a version control system.  </span><br><span class="line">+Git is a distributed version control system.  </span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure></p>
<p> git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。<br> 想查看git的日志可以<br> <code>$ git log</code><br> git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> $ git log --pretty=oneline  </span><br><span class="line">3628164fb26d48395383f8f31179f24e0882e1e0 append GPL  </span><br><span class="line">ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed  </span><br><span class="line">cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file  </span><br><span class="line">```  </span><br><span class="line">需要友情提示的是，你看到的一大串类似3628164...882e1e0的是commit id（版本号），和SVN不一样，Git的commitid不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。  </span><br><span class="line"></span><br><span class="line">每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：  </span><br><span class="line"></span><br><span class="line">如果提交了文件，存在错误想撤销回到上一个版本：</span><br></pre></td></tr></table></figure></p>
<p>$ git reset –hard HEAD^<br>HEAD is now at ea34578 add distributed<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。  </span><br><span class="line"></span><br><span class="line">例如:</span><br></pre></td></tr></table></figure></p>
<p>$ git log<br>commit ea34578d5496d7dd233c827ed32a8cd576c5ee85<br>Author: Michael Liao <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x61;&#115;&#x6b;&#120;&#x75;&#101;&#x66;&#x65;&#110;&#103;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;">&#x61;&#115;&#x6b;&#120;&#x75;&#101;&#x66;&#x65;&#110;&#103;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;</a><br>Date:   Tue Aug 20 14:53:12 2013 +0800  </p>
<pre><code>add distributed  
</code></pre><p>commit cb926e7ea50ad11b8f9e909c05226233bf755030<br>Author: Michael Liao <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#97;&#x73;&#107;&#120;&#117;&#x65;&#x66;&#101;&#x6e;&#103;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;">&#97;&#x73;&#107;&#120;&#117;&#x65;&#x66;&#101;&#x6e;&#103;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;</a><br>Date:   Mon Aug 19 17:51:55 2013 +0800  </p>
<pre><code>wrote a readme file  
</code></pre><p>$ git reset –hard 3628164<br>HEAD is now at 3628164 append GPL  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">那么文件已经成功的回退到指定的版本。  </span><br><span class="line">现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？  </span><br><span class="line"></span><br><span class="line">在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</span><br></pre></td></tr></table></figure>
<p>$ git reflog<br>ea34578 HEAD@{0}: reset: moving to HEAD^<br>3628164 HEAD@{1}: commit: append GPL<br>ea34578 HEAD@{2}: commit: add distributed<br>cb926e7 HEAD@{3}: commit (initial): wrote a readme file  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">说到这里，那么下面来认识一下git 工作区和暂存区  </span><br><span class="line"></span><br><span class="line">所谓的工作区，就是你现在本地的能看的目录比如刚刚创建的learngit就是你的工作区  </span><br><span class="line">版本库：就是你通过 $ git commit 把目录提交到的地方，  </span><br><span class="line">前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</span><br><span class="line"></span><br><span class="line">第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；  </span><br><span class="line"></span><br><span class="line">第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 </span><br><span class="line"></span><br><span class="line">可以查看暂存区和最近一次提交的不同:  </span><br><span class="line">` $ git diff --cached `  </span><br><span class="line">注意的是，只有在 暂存区的文件commit后才能提交到版本库当中。  </span><br><span class="line"></span><br><span class="line">git diff：是查看工作区与暂存区的差别的。   </span><br><span class="line">git diff --cached：是查看暂存区与commit的差别的。  </span><br><span class="line">git diff HEAD：是查看工作区和commit的差别的。（你一定没有忘记，HEAD代表的是最近的一次commit的信息）  </span><br><span class="line"></span><br><span class="line">学会了 提交、查看那么又有人会问到，如果我写错了，想撤销我刚才的操作该如何做呢！别急下面介绍一下如何撤销：  </span><br><span class="line">你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改：  </span><br><span class="line">`$ git checkout -- readme.txt`  </span><br><span class="line">命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：  </span><br><span class="line">一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；  </span><br><span class="line">一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。  </span><br><span class="line">总之，就是让这个文件回到最近一次git commit或git add时的状态。  </span><br><span class="line"></span><br><span class="line">Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：</span><br></pre></td></tr></table></figure>
<p>$ git reset HEAD readme.txt<br>Unstaged changes after reset:<br>M       readme.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。  </span><br><span class="line"></span><br><span class="line">创建完了，那么我想删除刚刚创建的文件该如何操作呢?    </span><br><span class="line">第一步：首先是从你本地删除，第二步其次是从版本库中删除掉</span><br></pre></td></tr></table></figure>
<p>$ git rm test.txt<br>rm ‘test.txt’<br>$ git commit -m “remove test.txt”<br>[master d17efd8] remove test.txt<br> 1 file changed, 1 deletion(-)<br> delete mode 100644 test.txt  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">现在，文件就从版本库中被删除了。  </span><br><span class="line"></span><br><span class="line">另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：  </span><br><span class="line"></span><br><span class="line">`$ git checkout -- test.txt`  </span><br><span class="line"></span><br><span class="line">git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。  </span><br><span class="line">命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。  </span><br><span class="line"></span><br><span class="line">到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。  </span><br><span class="line">其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。  </span><br><span class="line">实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</span><br><span class="line"></span><br><span class="line">完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。  </span><br><span class="line">在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：  </span><br><span class="line"></span><br><span class="line">####远程仓库连接  </span><br><span class="line"></span><br><span class="line">第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：  </span><br><span class="line"></span><br><span class="line">`$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;`  </span><br><span class="line"></span><br><span class="line">你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。  </span><br><span class="line"></span><br><span class="line">如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH   Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。  </span><br><span class="line"></span><br><span class="line">第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</span><br><span class="line"></span><br><span class="line">然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：   </span><br><span class="line">为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。  </span><br><span class="line"></span><br><span class="line">当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。  </span><br><span class="line"></span><br><span class="line">准备工作已经做好了，那么如何 让本地的文件同步到github上去呢？ 接下来小编告诉你。  </span><br><span class="line"></span><br><span class="line">首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：  </span><br><span class="line">在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：  </span><br><span class="line">现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：  </span><br><span class="line">` $ git remote add origin git@github.com:michaelliao/learngit.git `</span><br><span class="line">注意：把上面的michaelliao替换成你自己的GitHub账户名  </span><br><span class="line"></span><br><span class="line">添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。  </span><br><span class="line">下一步，就可以把本地库的所有内容推送到远程库上：</span><br></pre></td></tr></table></figure>
<p>$ git push -u origin master<br>Counting objects: 19, done.<br>Delta compression using up to 4 threads.<br>Compressing objects: 100% (19/19), done.<br>Writing objects: 100% (19/19), 13.73 KiB, done.<br>Total 23 (delta 6), reused 0 (delta 0)<br>To git@github.com:michaelliao/learngit.git  </p>
<ul>
<li>[new branch]      master -&gt; master<br>Branch master set up to track remote branch master from origin.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。  </span><br><span class="line"></span><br><span class="line">由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。  </span><br><span class="line"></span><br><span class="line">推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样  </span><br><span class="line"></span><br><span class="line">从现在起，只要本地作了提交，就可以通过命令：  </span><br><span class="line"></span><br><span class="line">` $ git push origin master `</span><br></pre></td></tr></table></figure>
<p>去除本地仓库与远程仓库的关联: $ git remote rm origin(远程仓库)<br>克隆了别人的远程仓库到自己本地工作区，但是想把这种关联到自己的远层仓库:$ git remote set-url origin git@your-new-url  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SSH警告  </span><br><span class="line"></span><br><span class="line">当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：  </span><br><span class="line"></span><br><span class="line">The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.  </span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.  </span><br><span class="line">Are you sure you want to continue connecting (yes/no)?  </span><br><span class="line"></span><br><span class="line">这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。  </span><br><span class="line"></span><br><span class="line">Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：  </span><br><span class="line"></span><br><span class="line">Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts.  </span><br><span class="line"></span><br><span class="line">这个警告只会出现一次，后面的操作就不会有任何警告了。  </span><br><span class="line"></span><br><span class="line">如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。  </span><br><span class="line"></span><br><span class="line">如何让github的文件克隆到本地的工作区域中：</span><br></pre></td></tr></table></figure>
<p>$ git clone git@github.com:michaelliao/gitskills.git<br>Cloning into ‘gitskills’…<br>remote: Counting objects: 3, done.<br>remote: Total 3 (delta 0), reused 0 (delta 0)<br>Receiving objects: 100% (3/3), done.  </p>
<p>$ cd gitskills<br>$ ls<br>README.md  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。  </span><br><span class="line">那么开始创建一个分支  </span><br><span class="line"></span><br><span class="line">首先，我们创建dev分支，然后切换到dev分支：</span><br></pre></td></tr></table></figure>
<p>$ git checkout -b dev<br>Switched to a new branch ‘dev’  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</span><br></pre></td></tr></table></figure>
<p>$ git branch dev<br>$ git checkout dev<br>Switched to branch ‘dev’  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后，用git branch命令查看当前分支：</span><br></pre></td></tr></table></figure>
<p>$ git branch  </p>
<ul>
<li>dev<br>master  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch命令会列出所有分支，当前分支前面会标一个*号。  </span><br><span class="line"></span><br><span class="line">然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：  </span><br><span class="line"></span><br><span class="line">然后提交：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$ git add readme.txt<br>$ git commit -m “branch test”<br>[dev fec145a] branch test<br> 1 file changed, 1 insertion(+)  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在，dev分支的工作完成，我们就可以切换回master分支：</span><br></pre></td></tr></table></figure>
<p>$ git checkout master<br>Switched to branch ‘master’  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：  </span><br><span class="line"></span><br><span class="line">现在，我们把dev分支的工作成果合并到master分支上：</span><br></pre></td></tr></table></figure>
<p>$ git merge dev<br>Updating d17efd8..fec145a<br>Fast-forward<br> readme.txt |    1 +<br> 1 file changed, 1 insertion(+)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。  </span><br><span class="line"></span><br><span class="line">注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。  </span><br><span class="line"></span><br><span class="line">当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。  </span><br><span class="line"></span><br><span class="line">合并完成后，就可以放心地删除dev分支了：</span><br></pre></td></tr></table></figure></p>
<p>$ git branch -d dev<br>Deleted branch dev (was fec145a).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">删除后，查看branch，就只剩下master分支了：  </span><br><span class="line"></span><br><span class="line">$ git branch  </span><br><span class="line">* master  </span><br><span class="line"></span><br><span class="line">因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。  </span><br><span class="line"></span><br><span class="line"> Git鼓励大量使用分支：  </span><br><span class="line"></span><br><span class="line">查看分支：git branch  </span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;  </span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;  </span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;  </span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;  </span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;  </span><br><span class="line"></span><br><span class="line">有分支就会有冲突  </span><br><span class="line">如果您把分支上的文件修改后，提交到版本库中，切换到主干上，然后修改文件后 也提交，然后合并分支和master上面的 内容，就会发生 冲突我们可以直接查看readme.txt的内容：</span><br></pre></td></tr></table></figure></p>
<pre><code>Git is a distributed version control system.  
Git is free software distributed under the GPL.  
Git has a mutable index called stage.  
Git tracks changes of files.    
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple. 再提交：</span><br></pre></td></tr></table></figure>
<pre><code>$ git add readme.txt   
$ git commit -m &quot;conflict fixed&quot;  
[master 59bc1cb] conflict fixed   
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">冲突解决了，可以安心 编写程序了  </span><br><span class="line"></span><br><span class="line">还可以用带参数的git log也可以看到分支的合并情况：</span><br></pre></td></tr></table></figure>
<p>$ git log –graph –pretty=oneline –abbrev-commit  </p>
<ul>
<li>59bc1cb conflict fixed<br>|\<br>| * 75a857c AND simple  </li>
<li>| 400b400 &amp; simple<br>|/  </li>
<li>fec145a branch test<br>…  </li>
</ul>
<p>最后，删除feature1分支：  </p>
<p>$ git branch -d feature1<br>Deleted branch feature1 (was 75a857c).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。  </span><br><span class="line">如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。  </span><br><span class="line">准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：</span><br></pre></td></tr></table></figure></p>
<p>$ git merge –no-ff -m “merge with no-ff” dev<br>Merge made by the ‘recursive’ strategy.<br> readme.txt |    1 +<br> 1 file changed, 1 insertion(+)<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。  </span><br><span class="line"></span><br><span class="line">合并后，我们用git log看看分支历史：</span><br></pre></td></tr></table></figure></p>
<p>$ git log –graph –pretty=oneline –abbrev-commit  </p>
<ul>
<li>7825a50 merge with no-ff<br>|\<br>| * 6224937 add merge<br>|/  </li>
<li>59bc1cb conflict fixed<br>…  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那么分支也创建完成，小编想看下我管理的所有仓库：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$ git remote -v<br>origin  git@github.com:michaelliao/learngit.git (fetch)<br>origin  git@github.com:michaelliao/learngit.git (push)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。  </span><br><span class="line"></span><br><span class="line">查看了有几个仓库后，小编看了看分支，时间久了后，却忘记了当时创建分支的初衷，后便又想起来，给分支加上标签：  </span><br><span class="line">敲命令git tag &lt;name&gt;就可以打一个新标签：  </span><br><span class="line"></span><br><span class="line">`$ git tag v1.0`  </span><br><span class="line"></span><br><span class="line">可以用命令git tag查看所有标签：  </span><br><span class="line"></span><br><span class="line">`$ git tag`  </span><br><span class="line">`v1.0`  </span><br><span class="line"></span><br><span class="line">默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？  </span><br><span class="line"></span><br><span class="line">方法是找到历史提交的commit id，然后打上就可以了：</span><br></pre></td></tr></table></figure>
<pre><code>$ git log --pretty=oneline --abbrev-commit  
6a5819e merged bug fix 101  
cc17032 fix bug 101  
7825a50 merge with no-ff  
6224937 add merge  
59bc1cb conflict fixed  
400b400 &amp; simple  
75a857c AND simple  
fec145a branch test  
d17efd8 remove test.txt  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：</span><br><span class="line"></span><br><span class="line">`$ git tag v0.9 6224937`  </span><br><span class="line"></span><br><span class="line">注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息：</span><br></pre></td></tr></table></figure>
<pre><code>$ git show v0.9  
commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4  
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;  
Date:   Thu Aug 22 11:22:08 2013 +0800  

add merge  
</code></pre><p>…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以看到，v0.9确实打在add merge这次提交上。  </span><br><span class="line"></span><br><span class="line">还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：  </span><br><span class="line"></span><br><span class="line">`$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164`  </span><br><span class="line"></span><br><span class="line">如果标签打错了，也可以删除：</span><br></pre></td></tr></table></figure></p>
<pre><code>$ git tag -d v0.1  
Deleted tag &apos;v0.1&apos; (was e078af9)  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。  </span><br><span class="line"></span><br><span class="line">如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;：</span><br></pre></td></tr></table></figure>
<pre><code>$ git push origin v1.0  
Total 0 (delta 0), reused 0 (delta 0)  
To git@github.com:michaelliao/learngit.git  
 * [new tag]         v1.0 -&gt; v1.0  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">或者，一次性推送全部尚未推送到远程的本地标签：</span><br></pre></td></tr></table></figure>
<pre><code>$ git push origin --tags  
Counting objects: 1, done.  
Writing objects: 100% (1/1), 554 bytes, done.  
Total 1 (delta 0), reused 0 (delta 0)  
To git@github.com:michaelliao/learngit.git  
 * [new tag]         v0.2 -&gt; v0.2  
 * [new tag]         v0.9 -&gt; v0.9  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</span><br></pre></td></tr></table></figure>
<p>$ git tag -d v0.9<br>Deleted tag ‘v0.9’ (was 6224937)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后，从远程删除。删除命令也是push，但是格式如下：</span><br></pre></td></tr></table></figure></p>
<p>$ git push origin :refs/tags/v0.9<br>To git@github.com:michaelliao/learngit.git  </p>
<ul>
<li>[deleted]         v0.9  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要看看是否真的从远程库删除了标签，可以登陆GitHub查看。    </span><br><span class="line">  </span><br><span class="line">有没有经常敲错命令？比如git status？status这个单词真心不好记。  </span><br><span class="line"></span><br><span class="line">如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。  </span><br><span class="line"></span><br><span class="line">我们只需要敲一行命令，告诉Git，以后st就表示status：  </span><br><span class="line"></span><br><span class="line">`$ git config --global alias.st status`  </span><br><span class="line"></span><br><span class="line">当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$ git config –global alias.co checkout<br>$ git config –global alias.ci commit<br>$ git config –global alias.br branch<br>```</p>
<p>以后提交就可以简写成：  </p>
<p><code>$ git ci -m &quot;bala bala bala...&quot;</code>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/06/git/" data-id="cinhdu2m50004e4vd69ig5e8e" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/03/06/git/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git安装/">git安装</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git安装/">git安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo使用/">hexo使用</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/git安装/" style="font-size: 10px;">git安装</a> <a href="/tags/hexo使用/" style="font-size: 10px;">hexo使用</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/04/26/angular/">理解ANGULAR中的$APPLY()以及 $DIGEST()</a>
          </li>
        
          <li>
            <a href="/2016/03/06/hexo/">hexo</a>
          </li>
        
          <li>
            <a href="/2016/03/06/git/">git</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 [object Object]<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'liuxiufang';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>